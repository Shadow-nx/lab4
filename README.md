# lab4 

Вывод:

B::foo();

B::bar();

A::baz();

C::foo();

C::bar();

A::baz();

A* a1 = new B; - выделяется память под указатель типа A c именем a1;

1)a1->foo(); = B::foo(); функция foo() является виртуальной поэтому хранится в таблице виртуальных методов и переопределяется в каждом дочернем классе,поэтому при вызове конструктора дочернего класса B она была переопределена и при обращение к foo мы уже обращаемся к ее переопределенной версии в дочернем классе B;

2)a1->bar(); = B::baz(); функция bar() является виртуальной в родительском классе A поэтому хранится в таблице виртуальных методов и переопределяется в каждом дочернем классе,поэтому при вызове конструктора дочернего класса B она была переопределена и при обращение к bar(); мы уже обращаемся к ее переопределенной версии в дочернем классе B;

3)a1->baz(); = A::baz(); функция baz(); не явлчется виртуальной функцией поэтому не вносится в таблицу вирнтуальных методов и не переопределяется 

A* a2 = new C; - выделяется память под указатель типа A c именем a1;

4)a2->foo(); = C::foo(); функция foo() является виртуальной поэтому хранится в таблице виртуальных методов и переопределяется в каждом дочернем классе,поэтому при вызове конструктора дочернего класса C она была переопределена и при обращение к foo мы уже обращаемся к ее переопределенной версии в дочернем классе C;

5)a2->bar(); = C::bar(); функция bar() является виртуальной в родительском классе A поэтому хранится в таблице виртуальных методов и переопределяется в каждом дочернем классе,поэтому при вызове конструктора дочернего класса C она была переопределена и при обращение к bar(); мы уже обращаемся к ее переопределенной версии в дочернем классе C;

6)a2->baz(); = A::baz(); функция baz(); не явлчется виртуальной функцией поэтому не вносится в таблицу вирнтуальных методов и не переопределяется в дочерних классах,поэтому имея обьект типа A мы будем обращаться к функции bar(); находящийся в классе A 
 


